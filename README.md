# BlockOrgan - Organ Donation Registry

A blockchain-verified organ donation matching platform that connects donors with recipients using a secure, transparent system built with Next.js, Firebase, and TypeScript.



‚ÄºÔ∏è‚ÄºÔ∏è **Note**: If you think the project is compleately made by ai, it's not the whole frontend is only generated by v0 and other than the logic is build by me and im the solo dev so i dont have any choice.

## üöÄ Features

- **User Authentication**
  - Email/Password and Google Sign-In
  - Role-based access control (Donor/Recipient/Admin)
  - Secure session management

- **Donor Management**
  - Register as an organ donor
  - Specify organs available for donation
  - Track donation status

- **Recipient Management**
  - Register organ needs
  - Match with compatible donors
  - Track matching status

- **Matching System**
  - Automated compatibility scoring
  - Real-time notifications
  - Secure decision-making via email tokens

- **Admin Dashboard**
  - System monitoring
  - User management
  - Analytics and reporting

## üèóÔ∏è Architecture

### Tech Stack

- **Frontend**: Next.js 13+ with TypeScript
- **Styling**: Tailwind CSS with shadcn/ui components
- **Authentication**: Firebase Authentication
- **Database**: Firestore (NoSQL)
- **Email**: Nodemailer with SMTP
- **Blockchain**: Avalanche (C-Chain) via `ethers` for on-chain user verification
- **Deployment**: Vercel (Frontend) + Firebase Hosting (Backend)

### Data Model

#### Users
- `usersPublic/{uid}`: Public user data (role, email, timestamps)
- `donors/{uid}`: Private donor information
- `recipients/{uid}`: Private recipient information

#### Matching
- `matches/{donorUid__recipientUid}`: Match records with scores
- `emailLogs/{logId}`: Email notification tracking

## üîÑ Matching Algorithm

### Compatibility Scoring
1. **Blood Type Match** (20 points)
   - Identical blood type: +20
   - Compatible types: +10
   - Incompatible: 0

2. **Organ Match** (10 points)
   - Donor's organs include recipient's needed organ: +10
   - No match: 0

3. **Age Proximity** (0-10 points)
   - Age difference ‚â§ 10 years: +10
   - Each additional 10 years: -1 (max -10)

### Matching Process
1. User triggers matching via dashboard
2. System identifies user role (donor/recipient)
3. Finds compatible counterparts based on medical criteria
4. Creates match records for scores ‚â• 20
5. Sends secure email notifications to both parties

## üõ†Ô∏è Development Setup

### Prerequisites
- Node.js 18+
- Firebase project with Authentication and Firestore enabled
- SMTP email service (e.g., Gmail, SendGrid)

### Installation

```bash
# Clone the repository
git clone https://github.com/yourusername/blockorgan.git
cd blockorgan

# Install dependencies
npm install

# Set up environment variables
cp .env.example .env.local
# Edit .env.local with your Firebase and email settings

# Run development server
npm run dev
```

### Environment Variables

Create a `.env.local` file with:

```env
# Firebase
NEXT_PUBLIC_FIREBASE_API_KEY=your_api_key
NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=your_project_id.firebaseapp.com
NEXT_PUBLIC_FIREBASE_PROJECT_ID=your_project_id

# Email
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your_email@gmail.com
SMTP_PASS=your_app_password

# Avalanche (C-Chain)
# Smart contract must implement registerUser(string uid) and isUserRegistered(string uid)
AVALANCHE_CONTRACT_ADDRESS=0xYourContractAddress
AVALANCHE_PRIVATE_KEY=0xyour_deployer_or_service_wallet_private_key
AVALANCHE_RPC_URL=https://api.avax.network/ext/bc/C/rpc

# Optional: Use Firestore Emulator
NEXT_PUBLIC_USE_FIRESTORE_EMULATOR=true
```

## ‚õìÔ∏è Avalanche On-Chain Verification

This project anchors minimal identity (user UID) to the Avalanche C-Chain to provide tamper-evident verification that a user exists in the registry.

### Smart Contract Requirements

Your contract must expose the following functions (string-based UID):

```solidity
function registerUser(string calldata uid) external returns (bool);
function isUserRegistered(string calldata uid) external view returns (bool);
```

The app uses a minimal ABI located in `lib/chain.ts`.

### Flow

1. User signs in and lands on the dashboard (`app/dashboard/page.tsx`).
2. The dashboard calls `POST /api/users/register` with `{ uid, email, role }` to:
   - Upsert a minimal public user record in Firestore (`usersPublic/{uid}`).
   - Check if `uid` exists on-chain via `isUserRegistered`.
   - If not, call `registerUser(uid)` and return the transaction hash when available.
3. The response includes `{ onChain: boolean, txHash?: string }` which is shown in the UI.
4. As a fallback or for manual checks, the dashboard can call `POST /api/verify` with `{ uid }` to return `{ exists: boolean }` from the chain.

### Relevant Files

- `lib/chain.ts`: Ethers-based utility that connects to Avalanche using `AVALANCHE_*` env vars and exposes `verifyUserOnChain(uid)` and `registerUserOnChain(uid)`.
- `app/api/users/register/route.ts`: Upserts Firestore user record and ensures the user is registered on-chain.
- `app/api/verify/route.ts`: Verifies existence of a UID on-chain.
- `app/dashboard/page.tsx`: Displays real-time verification status and transaction hash in the UI.

### Dependency

- `ethers` v6 is used to interact with the Avalanche RPC and your contract.

## üîí Security

- Role-based access control
- Data encryption in transit and at rest
- Secure token-based email decisions
- Firestore security rules for data protection
- Rate limiting on sensitive endpoints
- Do not expose private keys to the client. `AVALANCHE_PRIVATE_KEY` lives only on the server (Next.js route handlers).

## üìÑ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## ü§ù Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## üìß Contact

For questions or support, please contact the development team.
